export const CATEGORY_OPTIONS = {
  market: [
    "ì¹œí™˜ê²½",
    "ì œì² ê³¼ì¼",
    "ê°„í¸ê³¼ì¼",
    "ê²¬ê³¼ë¥˜",
    "ì¡ê³¡",
    "í‹°ë°±",
    "ìì°¨",
    "í—ˆë¸Œì°¨",
    "í™ì°¨",
    "ë…¹ì°¨",
    "ìŒˆì±„ì†Œ",
    "ë¿Œë¦¬ì±„ì†Œ",
    "ë²„ì„¯",
    "ìƒëŸ¬ë“œ",
    "ì¦™",
    "ì „ê³¨",
    "ë³¶ìŒ",
    "ì°Œê°œ",
    "êµ¬ì´",
    "ê°„ë‹¨ì‹",
    "ì£¼ìŠ¤",
    "íƒ„ì‚°",
    "ë‘ìœ ",
    "ì»¤í”¼",
    "ê³¼ì",
    "ì´ˆì½œë¦¿",
    "ìº”ë””",
    "ì ¤ë¦¬",
    "ë–¡",
    "ì†Œê³ ê¸°",
    "ë¼ì§€ê³ ê¸°",
    "ë‹­ê³ ê¸°",
    "ì–‘ê³ ê¸°",
    "ê°€ê³µìœ¡",
    "ì˜¬ë¦¬ë¸Œì˜¤ì¼",
    "ì°¸ê¸°ë¦„",
    "ë“¤ê¸°ë¦„",
    "ì‹ìš©ìœ ",
    "ë²„í„°",
    "ì‹ë¹µ",
    "ì¼€ì´í¬",
    "ë””ì €íŠ¸",
    "ë² ì´ê¸€",
    "ìƒŒë“œìœ„ì¹˜",
    "ìš°ìœ ",
    "ìš”ê±°íŠ¸",
    "ì¹˜ì¦ˆ",
    "ê³„ë€",
  ],
  beauty: [
    "ìŠ¤í‚¨/í† ë„ˆ",
    "ë¡œì…˜",
    "í¬ë¦¼",
    "ì„¸ëŸ¼",
    "ë§ˆìŠ¤í¬",
    "ë² ì´ìŠ¤ë©”ì´í¬ì—…",
    "ë¸”ëŸ¬ì…”/í•˜ì´ë¼ì´íŠ¸",
    "ë¦½ë©”ì´í¬ì—…",
    "ì•„ì´ë©”ì´í¬ì—…",
    "ë°¤/ì˜¤ì¼",
    "ì›Œí„°",
    "í¼/ì ¤",
    "ë¦½/ì•„ì´ë¦¬ë¬´ë²„",
    "ì„ ìŠ¤í‹±",
    "ì„ ì¿ ì…˜",
    "ì„ í¬ë¦¼",
    "ìˆ˜ë”©",
    "ìƒ´í‘¸",
    "ì»¨ë””ì…”ë„ˆ",
    "íŠ¸ë¦¬íŠ¸ë¨¼íŠ¸",
    "ì˜¤ì¼",
    "ì›Œì‹œ",
    "ë¯¸ìŠ¤íŠ¸",
    "ë¦½ì¼€ì–´",
    "ê¸°íƒ€",
  ],
};

export const CATEGORY_OPTIONS_HOM = {
  market: [
    "ê³¼ì¼",
    "ì°¨",
    "ì±„ì†Œ",
    "ë°€í‚¤íŠ¸",
    "ìŒë£Œ",
    "ê°„ì‹",
    "ì •ìœ¡",
    "ì˜¤ì¼",
    "ë² ì´ì»¤ë¦¬",
    "ìœ ì œí’ˆ",
  ],
  beauty: ["ìŠ¤í‚¨ì¼€ì–´", "ë©”ì´í¬ì—…", "í´ë Œì§•", "ì„ ì¼€ì–´", "í—¤ì–´ì¼€ì–´", "ë°”ë””ì¼€ì–´"],
};

export const BRAND_OPTIONS = {
  market: ["ì˜¤ì„¤ë¡", "ì•°ì—”ì•°ì¦ˆ", "í…Œì¼ëŸ¬", "ë¯¸ë¯¸ë„¤", "ë”ë²¨ë¡œ", "ì‚¬ë¦¬ì›"],
  beauty: [
    "í—¤ë¼",
    "ë°”ì´ì˜¤ë”ë§ˆ",
    "í† ë¦¬ë“ ",
    "ë§ˆë…€ê³µì¥",
    "ë³´ë¹„ë¸Œë¼ìš´",
    "ì—ìŠ¤íŠ¸ë¼",
    "ì•„ë² ë‹¤",
    "ê¼¬ë‹¬ë¦¬",
    "ëª¨ë¡œì¹¸ì˜¤ì¼",
    "ìë¹ˆë“œì„œìš¸",
    "í”„ë ˆì‹œì•ˆ",
    "ë‹¬ë°”",
    "ì•„ë¥´ë§ˆë‹ˆë·°í‹°",
    "ë‘ì½¤",
    "ë§¥",
    "ê¹€ì •ë¬¸ì•Œë¡œì—",
    "ë¦´ë¦¬ë°”ì´ë ˆë“œ",
  ],
  fashion: [
    "ì—˜ë Œì¥¬ì–¼ë¦¬",
    "ë² ííŠ¸",
    "ë°”ì´ì´ì´ì—ë¥´",
    "ë“€ì´ë“€ì´",
    "ë£¨ì‹œë‹¤",
    "R2W",
    "ë©”ë¥´ì‹œë§ˆë¦¬ì—",
    "ìŠ¬ë¡œìš°ë¡¤ë¦¬",
    "ì•¤í´ë¼ì¸",
    "ë°”ì´ë“€",
    "ê³ ë“œë‚˜íŠ¸",
  ],
  living: ["ë‹ˆë„", "3M", "ì•„ë§ë–¼", "í”„ë¡œê·¸", "ë´ë¹„"],
};

export const FILTER_OPTIONS_MAP = (category, isHOM = false) => ({
  ì¹´í…Œê³ ë¦¬: isHOM
    ? (CATEGORY_OPTIONS_HOM[category] ?? [])
    : (CATEGORY_OPTIONS[category] ?? []),
  ê°€ê²©: ["~5000ì›", "5000ì›~15000ì›", "15000ì›~25000ì›", "25000ì› ì´ìƒ"],
  ë¸Œëœë“œ: BRAND_OPTIONS[category] ?? [],
  í”¼ë¶€íƒ€ì…: ["ê±´ì„±", "ì§€ì„±", "ë³µí•©ì„±", "ë¯¼ê°ì„±", "ì¤‘ì„±"],
  ìœ í˜•: ["KurlyOnly"],
  í˜œíƒ: ["ì¿ í° ì ìš©", "íŠ¹ê°€", "ì¦ì •", "ë¬¶ìŒ"],
  ì¶œì‹œ: ["ì‹ ìƒí’ˆ"],
  í¬ì¥íƒ€ì…: ["ëƒ‰ì¥", "ëƒ‰ë™", "ìƒì˜¨"],
  ë°°ì†¡: ["ìƒ›ë³„ë°°ì†¡", "íƒë°°ë°°ì†¡"],
});

/**
 * ë‹¨ì¼ productê°€ íŠ¹ì • íƒ­ì˜ íŠ¹ì • ì˜µì…˜ì— ë§¤ì¹­ë˜ëŠ”ì§€ í™•ì¸
 * @param {object} product
 * @param {string} tab - í•„í„° íƒ­ ì´ë¦„
 * @param {string} option - ì„ íƒëœ ì˜µì…˜
 */
export const matchesFilter = (product, tab, option) => {
  switch (tab) {
    case "ê°€ê²©": {
      const finalPrice = Math.round(
        product.originalPrice * (1 - product.discountRate / 100),
      );
      if (option === "~5000ì›") return finalPrice <= 5000;
      if (option === "5000ì›~15000ì›")
        return finalPrice > 5000 && finalPrice <= 15000;
      if (option === "15000ì›~25000ì›")
        return finalPrice > 15000 && finalPrice <= 25000;
      if (option === "25000ì› ì´ìƒ") return finalPrice > 25000;
      return true;
    }
    case "ë¸Œëœë“œ":
      console.log(
        `ğŸ” [matchesFilter ë¸Œëœë“œ] product.brandName: "${product.brandName}", option: "${option}", match: ${product.brandName === option}`,
      );
      return product.brandName === option;
    case "ì¹´í…Œê³ ë¦¬":
      return product.category?.includes(option);
    case "ìœ í˜•":
      return option === "KurlyOnly" && product.isKurlyOnly;
    case "í˜œíƒ":
      if (option === "ì¿ í° ì ìš©") return product.topBadgeText?.includes("ì¿ í°");
      if (option === "íŠ¹ê°€")
        return (
          product.topBadgeText?.includes("íŠ¹ê°€") ||
          product.bottomBannerText?.includes("íŠ¹ê°€")
        );
      if (option === "ì¦ì •") return product.topBadgeText?.includes("ì¦ì •");
      if (option === "ë¬¶ìŒ")
        return (
          product.topBadgeText?.includes("ê¸°íš") ||
          product.topBadgeText?.includes("ë¬¶ìŒ")
        );
      return true;
    case "ì¶œì‹œ": {
      const today = new Date();
      const created = new Date(product.createdAt);
      const diffDays = (today - created) / (1000 * 60 * 60 * 24);
      if (option === "ì‹ ìƒí’ˆ") return diffDays <= 50;
      return true;
    }
    case "í¬ì¥íƒ€ì…":
      return product.packagingType === option;
    case "ë°°ì†¡":
      if (option === "ìƒ›ë³„ë°°ì†¡") return product.isDawnDelivery === true;
      if (option === "íƒë°°ë°°ì†¡") return product.isDawnDelivery === false;
      return false;
    case "í”¼ë¶€íƒ€ì…":
      return product.skinType === option;
    default:
      return true;
  }
};

/**
 * checkFilter(ì„ íƒëœ ì˜µì…˜ ë°°ì—´)ë¥¼ ì´ìš©í•´ productsë¥¼ í•„í„°ë§
 * - íƒ­ ë‚´ OR, íƒ­ ê°„ AND
 * @param {object[]} products
 * @param {string[]} checkFilter
 * @param {string} category - ì¹´í…Œê³ ë¦¬ ('market', 'beauty' ë“±)
 */
export const applyFilters = (products, checkFilter, category, isHOM) => {
  const optionsMap = FILTER_OPTIONS_MAP(category, isHOM);
  if (checkFilter.length === 0) return products;

  // íƒ­ë³„ë¡œ ì„ íƒëœ ì˜µì…˜ ë¶„ë¥˜
  const filterByTab = {};
  for (const [tab, options] of Object.entries(optionsMap)) {
    const selected = checkFilter.filter((o) => options.includes(o));
    if (selected.length > 0) filterByTab[tab] = selected;
  }

  // íƒ­ ê°„ AND, íƒ­ ë‚´ OR
  const filtered = products.filter((product) => {
    return Object.entries(filterByTab).every(([tab, selected]) => {
      return selected.some((opt) => matchesFilter(product, tab, opt));
    });
  });

  return filtered;
};
